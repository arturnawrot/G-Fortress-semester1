import os, json, base64, threading
from typing import Optional
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2


VAULT_FILE = os.getenv("GF_VAULT_FILE", "vault.json")   # where secrets are stored
ITER = int(os.getenv("GF_VAULT_ITER", "200000"))        # KDF iterations
MASTER_PASSWORD = os.getenv("GF_MASTER_PASSWORD")       # must be provided at runtime


def _b64e(b: bytes) -> str:
    """Base64-encode bytes → str (safe for JSON)."""
    return base64.b64encode(b).decode()

def _b64d(s: str) -> bytes:
    """Base64-decode str → bytes."""
    return base64.b64decode(s)

def _derive_key(passphrase: bytes, salt: bytes, iterations: int) -> bytes:
    """
    Derive a 32-byte AES key from a master password using PBKDF2-HMAC-SHA1.
    For stronger setups, swap PBKDF2 for Argon2id.
    """
    return PBKDF2(passphrase, salt, dkLen=32, count=iterations)

def _enc(plaintext: bytes, key: bytes) -> str:
    """
    Encrypt plaintext using AES-EAX (confidentiality + integrity).
    Returns nonce + tag + ciphertext, base64-encoded.
    """
    c = AES.new(key, AES.MODE_EAX)
    ct, tag = c.encrypt_and_digest(plaintext)
    return _b64e(c.nonce + tag + ct)

def _dec(blob: str, key: bytes) -> bytes:
    """
    Decrypt a base64-encoded blob produced by _enc().
    Splits nonce, tag, and ciphertext; verifies integrity.
    """
    data = _b64d(blob)
    nonce, tag, ct = data[:16], data[16:32], data[32:]
    c = AES.new(key, AES.MODE_EAX, nonce=nonce)
    return c.decrypt_and_verify(ct, tag)

# ---------------------------
# Secrets Manager Class
# ---------------------------

class SecretsManager:
    """
    A lightweight AES-encrypted vault for storing secrets.
    - Secrets are stored in a JSON file (`vault.json` by default).
    - Master password is stretched with PBKDF2 to derive the AES key.
    - Each secret is encrypted with AES-EAX (nonce + tag + ciphertext).
    - Supports string values (e.g. API keys) or JSON dicts (username/password pairs).
    """

    _lock = threading.RLock()  # ensures thread-safety if used across async/scanner threads

    def __init__(self, vault_file: str = VAULT_FILE, iterations: int = ITER, master_password: Optional[str] = MASTER_PASSWORD):
        if not master_password:
            raise RuntimeError("GF_MASTER_PASSWORD not set")
        self.vault_file = vault_file
        self.iterations = iterations
        self._master = master_password.encode()
        self._vault = self._load_or_init_vault()
        self._key = self._unlock()  # derive and validate key

    # ---------------------------
    # Internal helpers
    # ---------------------------

    def _load_or_init_vault(self):
        """Load existing vault JSON or create a new one with a fresh salt."""
        os.makedirs(os.path.dirname(self.vault_file) or ".", exist_ok=True)
        if not os.path.exists(self.vault_file):
            # Initialize vault with random salt
            salt = get_random_bytes(16)
            vault = {"version": 1, "salt": _b64e(salt), "iterations": self.iterations, "entries": {}}
            with open(self.vault_file, "w", encoding="utf-8") as f:
                json.dump(vault, f, indent=2)
            return vault
        with open(self.vault_file, "r", encoding="utf-8") as f:
            return json.load(f)

    def _save(self):
        """Write the current vault JSON to disk."""
        with open(self.vault_file, "w", encoding="utf-8") as f:
            json.dump(self._vault, f, indent=2)

    def _unlock(self) -> bytes:
        """Derive AES key from master password and validate with a check entry."""
        salt = _b64d(self._vault["salt"])
        iters = self._vault.get("iterations", self.iterations)
        key = _derive_key(self._master, salt, iters)
        chk = self._vault["entries"].get("__check__")
        if chk:
            # Decrypt check entry to validate correct master password
            _ = _dec(chk, key)
        else:
            # First-time vault init: store a check entry
            self._vault["entries"]["__check__"] = _enc(b"ok", key)
            self._save()
        return key

    # ---------------------------
    # Public API
    # ---------------------------

    def set_secret(self, name: str, data):
        """
        Encrypt and store a secret.
        - `data` can be a str (API token) or dict (e.g., {"u": "user", "p": "pass"}).
        """
        with self._lock:
            payload = data if isinstance(data, str) else json.dumps(data)
            self._vault["entries"][name] = _enc(payload.encode(), self._key)
            self._save()

    def get_secret(self, name: str):
        """
        Retrieve and decrypt a secret.
        - Returns dict if JSON-parsable, else returns raw string.
        """
        with self._lock:
            blob = self._vault["entries"].get(name)
            if not blob:
                return None
            raw = _dec(blob, self._key).decode()
            try:
                return json.loads(raw)
            except json.JSONDecodeError:
                return raw

    def list_secrets(self):
        """Return all stored secret names (excluding internal check entry)."""
        with self._lock:
            return sorted([k for k in self._vault["entries"].keys() if k != "__check__"])

    def delete_secret(self, name: str) -> bool:
        """Delete a secret by name. Returns True if deleted, False if missing."""
        with self._lock:
            if name in self._vault["entries"]:
                del self._vault["entries"][name]
                self._save()
                return True
            return False
