#!/usr/bin/env python3
import os, json, base64, getpass, argparse, tempfile, shutil
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2

def b64e(b): return base64.b64encode(b).decode()
def b64d(s): return base64.b64decode(s)

def derive_key(passphrase: bytes, salt: bytes, iterations: int) -> bytes:
    return PBKDF2(passphrase, salt, dkLen=32, count=iterations)

def aes_enc(plaintext: bytes, key: bytes) -> str:
    c = AES.new(key, AES.MODE_EAX)
    ct, tag = c.encrypt_and_digest(plaintext)
    return b64e(c.nonce + tag + ct)

def aes_dec(blob: str, key: bytes) -> bytes:
    data = b64d(blob)
    nonce, tag, ct = data[:16], data[16:32], data[32:]
    c = AES.new(key, AES.MODE_EAX, nonce=nonce)
    return c.decrypt_and_verify(ct, tag)

def rotate(vault_path: str, old_master: str, new_master: str, new_iters: int|None, dry_run: bool):
    if not os.path.exists(vault_path):
        raise SystemExit(f"Vault not found: {vault_path}")
    with open(vault_path, "r", encoding="utf-8") as f:
        vault = json.load(f)

    salt_old = b64d(vault["salt"])
    iters_old = int(vault.get("iterations", 200000))
    key_old = derive_key(old_master.encode(), salt_old, iters_old)

    # Validate old master via check entry
    chk = vault["entries"].get("__check__")
    if not chk:
        raise SystemExit("Vault missing __check__ entry; aborting.")
    try:
        aes_dec(chk, key_old)
    except Exception:
        raise SystemExit("Old master password is incorrect.")

    # Decrypt all entries into memory
    plaintext_map = {}
    for name, blob in vault["entries"].items():
        if name == "__check__": 
            continue
        plaintext_map[name] = aes_dec(blob, key_old)  # bytes

    if dry_run:
        print("Dry run OK: old master validated and entries decryptable.")
        return

    # Prepare new salt/iterations/key
    salt_new = get_random_bytes(16)
    iters_new = int(new_iters) if new_iters else iters_old
    key_new = derive_key(new_master.encode(), salt_new, iters_new)

    # Re-encrypt everything with the new key
    new_entries = {}
    for name, raw in plaintext_map.items():
        new_entries[name] = aes_enc(raw, key_new)
    new_entries["__check__"] = aes_enc(b"ok", key_new)

    # Write atomically with backup
    tmp_fd, tmp_path = tempfile.mkstemp(prefix="vault.", suffix=".tmp", dir=os.path.dirname(vault_path) or ".")
    os.close(tmp_fd)
    new_vault = {
        "version": vault.get("version", 1),
        "salt": b64e(salt_new),
        "iterations": iters_new,
        "entries": new_entries
    }
    with open(tmp_path, "w", encoding="utf-8") as f:
        json.dump(new_vault, f, indent=2)

    backup_path = vault_path + ".bak"
    shutil.copy2(vault_path, backup_path)
    shutil.move(tmp_path, vault_path)
    print(f"Rotation complete.\n- Updated: {vault_path}\n- Backup:  {backup_path}\n- Iterations: {iters_new}")

def main():
    ap = argparse.ArgumentParser(description="Rotate master password for AES vault")
    ap.add_argument("--vault", default=os.getenv("GF_VAULT_FILE", "vault.json"))
    ap.add_argument("--iterations", type=int, help="override iterations for new master")
    ap.add_argument("--dry-run", action="store_true", help="verify old master; no changes")
    args = ap.parse_args()

    old_master = getpass.getpass("Old master password: ")
    new_master = getpass.getpass("New master password: ")
    confirm = getpass.getpass("Confirm new master: ")
    if new_master != confirm:
        raise SystemExit("New master passwords do not match.")

    rotate(args.vault, old_master, new_master, args.iterations, args.dry_run)

if __name__ == "__main__":
    main()
